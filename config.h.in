// config.h
//
// Autogenerated from config.h.in by bsconf
//

#ifndef CONFIG_H_01F8552055DBC4246CF6E32537E15850
#define CONFIG_H_01F8552055DBC4246CF6E32537E15850

// Define to the one symbol short name of this package.
#define IFF_NAME       "@PACKAGE_NAME@"
// Define to the full name and version of this package.
#define IFF_STRING     "@PACKAGE_NAME@ @PACKAGE_VERSION@"
// Define to the version of this package.
#define IFF_VERSION    0x@LIB_MAJOR@@LIB_MINOR@@LIB_BUILD@
// Define to the address where bug reports for this package should be sent.
#define IFF_BUGREPORT  "@PACKAGE_BUGREPORT@"

// uSTL library is required to compile. You can get the latest version
// from http://sourceforge.net/projects/ustl
//
// Define to 1 if you have the <ustl.h> header file.
#undef HAVE_USTL_H

// The following two settings should be turned on for complete compatibility
// with the original EA85 IFF standard. The library defaults to the less
// compatible state for performance reasons. It is unlikely that there are
// many IFF files already in existence, nor is it likely that any ancient
// applications using EA85 IFF are still in use. Therefore it is assumed,
// that you will be creating your own files in this format, rather than
// reading some legacy data.
//
// Bigendian format was specified in the original standard because back in
// 1985 people (mostly academics with Sun machines obtained through a
// lucrative educational institution deal with Sun) were assuming that it
// will eventually become the standard. Since then the opposite has
// happened, and all desktop machines, including Macs, are now Intel-based
// little-endian. Because of this, this library defaults to the little-
// -endian format; if there are any big-endian machines still left, they
// should be the ones to do conversion work. Note that other people have
// made this very decision already, as evidenced by the Microsoft RIFF format.
//
// Define to USTL_BIG_ENDIAN if you want header fields in bigendian format.
#define IFF_BYTE_ORDER USTL_LITTLE_ENDIAN

// The EA85 standard specifies that each chunk must begin at an even file
// offset because the Motorola 68000 processor for which it was designed
// is not capable of addressing a dword at an odd address. The idea was
// to read the file into memory, or mmap it, and then read the dwords
// directly by casting memory address to uint. This is exactly what this
// library does. All the operations are defined for uSTL binary streams,
// which operate on memory blocks, read in or mmapped.
//
// Modern desktop CPUs are all using the Intel architecture, and require
// ints to be 4-byte aligned. While off-grain access does not cause a
// crash, like it did on the 68000, there is a significant performance
// penalty. For this reason, the default alignment is set to 4 instead
// of 2. Naturally, this only makes a difference in cases where the chunk
// size is not a multiple of 4, which should be pretty rare. Old programs,
// if any still exist, will still be able to read 4-grain files.
//
// Note that uSTL has its own alignment checks, so you'll have to turn
// those off as well to avoid assert failures.
//
// Define to 2 if you want chunks aligned on 2-grain instead of 4-grain.
// Define to 1 to turn off chunk alignment.
#define IFF_GRAIN 4

#if HAVE_USTL_H
    #include <ustl.h>
#else
    #error "uSTL library is required to compile. Get it at http://sourceforge.net/projects/ustl."
#endif
#if USTL_VERSION < 0x100
    #error "uSTL version 1.0.0 or later is required. Get it at http://sourceforge.net/projects/ustl."
#endif

#endif

